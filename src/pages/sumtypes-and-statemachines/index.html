{% from 'base.html' import heading, offsite_link, show_image %}
{{ page.set_title("State machines in C++17") }}

{% extends 'blog_entry.html' %}

{% block entry_content %}
<p>
Designing a library for Finite State Machines (FSM) is an interesting idea, because
it's such a <i>broad</i> concept. State machines represent a complete model of
computation, so it seems that either (a) supporting arbitrary state machines
requires a library with similar complexity to a complete programming language
or (b) <i>no</i> library is necessary, because a state machine encompasses just
a subset of everything the language is capable of already.
</p>

<p>
It turns out that this <i>can</i> be the case in many functional languages that
support such features as algebraic datatypes and pattern matching natively, but
certainly a small library can make implementing state machines easier and enforce
some level of consistency in imperative languages like C++.
</p>

{{ heading("What does a state machine library provide?") }}
<p>
In practice, most explicit state machines are event-driven, in that they only change state
or produce effects when some input changes (a timer expires, a button is pressed,
etc). Such FSMs usually consist of three things:
1. A finite list of possible states that machine can occupy.
2. Variables, some of which are shared across states and some of which might be
used by only one state.
3. Actions to perform upon specific events, and criteria upon which to transition
to a new state.
</p>

<p>
Some people break the third thing into two, but I tend to consider
the transitions themselves as actions as well because doing so usually gives a
little more versatility (which will be shown later).
</p>

{{ heading("Which libraries are out there?") }}
<p>
Within the realm of C++, the majority of state machine libraries occupy one of
two categories.
</p>

<p>
In the first of these categories, the user creates an enum with as many values
as there are states. The user then creates a class that holds an instance
of this enum, plus whichever variables are needed by any of the possible states.
The user also creates an enum that enumerates all the possible events the state
machine can handle.
Finally, they create a 2-dimensional "transition table", where upon receiving
an event, the state machine indexes the table based on the value of its state
enum and the event type to obtain a pointer to a function that performs some action
or alters some variables on the state machine and may yield a new state.
<p>

<p>
Among the downsides to this approach is the limitation that all states share all data.
This is a bit unclean (it's like declaring all your variables public, everywhere),
wastes memory and limits the extent to which the programmer can take advantage
of paradigms like RAII for management of state-specific resources. Additionally,
we might like for our events to have some associated data, but enums don't allow
for that.
</p>

<p>
The most promising library I could find is the Boost MSM. This does support
state-specific variables, which aren't visible to other states, but it looks
like they're still persisted across all states. So efficient usage of memory
and RAII still aren't possible.
</p>

{{ heading("Sum types") }}
<p>
C++17 offers <i>variant</i> types (also known as tagged unions or sum types).
A variant is much like the C union construct, but type safe.
Like a union, it allows a variable to be assigned <i>different types</i> throughout its lifetime,
but it only ever has one value at a time.
</p>

<p>
For those with experience in dynamic programming languages, it's not too different
from what languages like Python allow:
</p>

{{ multiline_code("""
def halve(x):
    if isinstance(x, int):
        return x/2
    elif isinstance(x, str):
        return x[0:len(x)/2]
    else:
        raise TypeError(\"Expected an int or str\")

>>> halve(24)
12
>>> halve('hello, world!')
'hello,'
""", "python") }}

<p>
In this case, x is similar to a sum type: it can be either an int or a string
and we only know at runtime. Today, this can be implemented in C++ as follows:
</p>

{{ multiline_code("""
typedef union {
    int,
    std::string,
} IntStrUnion;

struct IntStrSumType {
    /// Holds '0' to indicate 'data' is an int.
    /// Holds '1' to indicate 'data' is a string.
    int tag;
    IntStrUnion data;
};

IntStrSumType halve(const IntStrSumType& x) {
    if (x.tag == 0) {
        return IntStrSumType(0, *((int*)&x) / 2);
    } else if (x.tag == 1) {
         IntStrSumType(1,
            ((std::string*)&x)->substr(0, ((std::string*)&x)->length()/2));
    } else {
        DIE(\"Illegal type tag: expected 0 or 1\");
    }
}
""", "c++") }}

<p>
Note though that this method is incredibly error prone. Beyond the obvious,
memory leaks are difficult to avoid with this approach.
Because the compiler doesn't know
the type of the value contained in a union, it can't call any constructors when the value
is deleted. Thus, the caller will have to explicitly call the destructor of the appropriate type
when done with the returned value.
</p>

<p>
We could overcome some of these errors by wrapping this in a safer interface -
make a class whose destructor checks the tag of the union and calls the destructor of the
active type, then overload the assignment operator so that it sets the appropriate tag
based on if you assign it an int or a string, and finally make the tag private
and force all casts to be checked against the tag. This is essentially what
std::variant does, but it also introduces the concept of visitors.
</p>

<p>
Below is how the halve function could be implemented in C++17. Note the existence
of the overloaded keyword: this lets us overload lambda functions in the same
way that C++ lets one overload normal functions. The visit function does some
magic behind the scenes so that the tag will be checked at runtime and then the
appropriate overload of our lambda will be called. We'll make the syntax a bit
friendlier later on, too.
</p>

{{ multiline_code("""
#include <variant>

using IntStrSumType = std::variant<int, std::string>;

IntStrSumType halve(IntStrSumType x) {
    std::visit(overloaded {
            [](int&& x_int) {
                return x_int/2;
            },
            [](string&& x_str) {
                return x_str.substr(x_str.length()/2);
            }
        },
        x
    );
}
""", "c++") }}

{{ heading("State machines from sum types") }}


{% endblock %}
